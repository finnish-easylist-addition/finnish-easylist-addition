name: Publish test lists (uBO + AdGuard, per-file outputs, conditional diff + catch-up)

on:
  push:
    branches: [ master ]
    paths:
      - 'test.txt'
      - 'test_ubo_extras.txt'

permissions:
  contents: write

concurrency:
  group: publish-test-${{ github.ref }}
  cancel-in-progress: true

jobs:
  publish:
    runs-on: ubuntu-latest

    env:
      GH_EMAIL: "actions@users.noreply.github.com"
      GH_NAME:  "github-actions[bot]"
      SITE_DIR: "site"                 # gh-pages worktree
      PATCH_DIR: "patches"

      # Master-lähteet
      SRC_MAIN:   "test.txt"
      SRC_EXTRA:  "test_ubo_extras.txt"

      # gh-pages julkaisutiedostot (ERILLISET per lista ja per moottori)
      OUT_UBO_MAIN:   "test.txt"
      OUT_AG_MAIN:    "testAG.txt"
      OUT_UBO_EXTRA:  "test_ubo_extras.txt"
      OUT_AG_EXTRA:   "test_ubo_extrasAG.txt"

      # Snapshot-kansiot (per master-lähde)
      BASES_MAIN:   "bases/test-main"
      BASES_EXTRA:  "bases/test-extra"

      RETENTION_DAYS: "30"
      DIFF_EXPIRES_HUMAN: "5 hours"
      DIFF_EXPIRES_MIN:   "300"        # AdGuardin nimen loppuosa

    steps:
      - name: Checkout master
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Detect changed files (only rebuild what’s needed)
        id: detect
        run: |
          set -e
          BEFORE="${{ github.event.before }}"
          if [[ -z "$BEFORE" || "$BEFORE" == "0000000000000000000000000000000000000000" ]]; then
            # Ensimmäinen push tai epäselvä: rakenna molemmat parit
            echo "NEED_MAIN=1"  >> $GITHUB_ENV
            echo "NEED_EXTRA=1" >> $GITHUB_ENV
            exit 0
          fi
          CHANGED=$(git diff --name-only "$BEFORE" "${GITHUB_SHA}")
          echo "Changed files:"; echo "$CHANGED"

          NEED_MAIN=0; NEED_EXTRA=0
          echo "$CHANGED" | grep -q '^test\.txt$' && NEED_MAIN=1
          echo "$CHANGED" | grep -q '^test_ubo_extras\.txt$' && NEED_EXTRA=1

          # Liiketoimintasääntö:
          # - jos extras muuttui → päivitä AINA myös main-pari
          if [[ "$NEED_EXTRA" == "1" ]]; then
            NEED_MAIN=1
          fi

          echo "NEED_MAIN=${NEED_MAIN}"   >> $GITHUB_ENV
          echo "NEED_EXTRA=${NEED_EXTRA}" >> $GITHUB_ENV
          echo "Resolved NEED_MAIN=$NEED_MAIN NEED_EXTRA=$NEED_EXTRA"

      - name: Prepare gh-pages worktree
        run: |
          set -e
          git fetch --depth=1 origin gh-pages:gh-pages || true
          git worktree add "${SITE_DIR}" gh-pages || git checkout gh-pages
          mkdir -p "${SITE_DIR}/${PATCH_DIR}" "${SITE_DIR}/${BASES_MAIN}" "${SITE_DIR}/${BASES_EXTRA}"

      - name: Compute timestamps (Last modified: Europe/Helsinki; names: UTC)
        id: ts
        run: |
          RFC2822=$(TZ=Europe/Helsinki date -R)
          NOW_EPOCH=$(date -u +%s)
          EPOCH_MIN=$(( NOW_EPOCH / 60 ))
          echo "rfc2822=${RFC2822}"     >> $GITHUB_OUTPUT
          echo "now_epoch=${NOW_EPOCH}" >> $GITHUB_OUTPUT
          echo "epoch_min=${EPOCH_MIN}" >> $GITHUB_OUTPUT

      - name: Build headers for changed outputs
        run: |
          set -euo pipefail

          build_headers () {
            local src="$1" dest="$2"
            if [[ -f "${src}" ]]; then cp "${src}" raw.txt; else : > raw.txt; fi
            # Päivitä Last modified ja poista vanhat Diff-Path -rivit
            awk -v lm="! Last modified: ${RFC2822}" '
              BEGIN{ done_lm=0 }
              {
                if ($0 ~ /^! +Last modified:/) { if (!done_lm) { print lm; done_lm=1 }; next }
                if ($0 ~ /^! +Diff-Path:/)     { next }
                print
              }
              END { if (!done_lm) print lm }
            ' raw.txt > t1.txt

            # Lisää/korvaa Diff-Expires: 5 hours (älä koske ! Expires)
            if grep -qE '^! +Diff-Expires:' t1.txt; then
              sed -E "s/^! +Diff-Expires:.*/! Diff-Expires: ${DIFF_EXPIRES_HUMAN}/" t1.txt > t2.txt
            else
              awk -v d="! Diff-Expires: ${DIFF_EXPIRES_HUMAN}" '
                BEGIN{ added=0 }
                { print; if ($0 ~ /^! +Expires:/ && !added) { print d; added=1 } }
                END { if (!added) print d }
              ' t1.txt > t2.txt
            fi
            cp t2.txt "${dest}"
          }

          if [[ "${NEED_MAIN}" == "1" ]]; then
            build_headers "${SRC_MAIN}"  "${SITE_DIR}/${OUT_UBO_MAIN}"  # uBO-julkaisu
            build_headers "${SRC_MAIN}"  "${SITE_DIR}/${OUT_AG_MAIN}"   # AdGuard-julkaisu
          fi
          if [[ "${NEED_EXTRA}" == "1" ]]; then
            build_headers "${SRC_EXTRA}" "${SITE_DIR}/${OUT_UBO_EXTRA}" # uBO-julkaisu
            build_headers "${SRC_EXTRA}" "${SITE_DIR}/${OUT_AG_EXTRA}"  # AdGuard-julkaisu
          fi
        env:
          RFC2822: ${{ steps.ts.outputs.rfc2822 }}
          NEED_MAIN:  ${{ env.NEED_MAIN }}
          NEED_EXTRA: ${{ env.NEED_EXTRA }}

      - name: Add Diff-Path lines (point to correct patch names)
        run: |
          set -euo pipefail
          NOW_EPOCH=${{ steps.ts.outputs.now_epoch }}
          EPOCH_MIN=${{ steps.ts.outputs.epoch_min }}

          # uBO-heuristinen patchin nimi (yksi per ajokerta; sisältää 1–2 lohkoa)
          Y=$(date -u -d "@${NOW_EPOCH}" +%Y)
          Mo=$(date -u -d "@${NOW_EPOCH}" +%-m)
          D=$(date -u -d "@${NOW_EPOCH}" +%-d)
          H=$(date -u -d "@${NOW_EPOCH}" +%H)
          Mi=$(date -u -d "@${NOW_EPOCH}" +%M)
          MINS=$(( 10#${H}*60 + 10#${Mi} ))
          PATCH_UBO="${Y}.${Mo}.${D}.${MINS}.patch"
          REL_UBO="${PATCH_DIR}/${PATCH_UBO}"

          # AdGuard-patchien nimet per julkaisu
          PATCH_AG_MAIN="testAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
          REL_AG_MAIN="${PATCH_DIR}/${PATCH_AG_MAIN}"
          PATCH_AG_EXTRA="test_ubo_extrasAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
          REL_AG_EXTRA="${PATCH_DIR}/${PATCH_AG_EXTRA}"

          add_path () {
            local file="$1" rel="$2" frag="$3"
            awk '!/^! +Diff-Path:/' "$file" > tmp && mv tmp "$file"
            awk -v p="! Diff-Path: '"${rel}"'#"'"${frag}"'" ' \
                'BEGIN{ins=0} { print; if ($0 ~ /^! +Diff-Expires:/ && !ins) { print p; ins=1 } } END{ if (!ins) print p }' \
                "$file" > tmp && mv tmp "$file"
          }

          if [[ "${NEED_MAIN}" == "1" ]]; then
            add_path "${SITE_DIR}/${OUT_UBO_MAIN}"  "${REL_UBO}"    "test.txt"           # uBO
            add_path "${SITE_DIR}/${OUT_AG_MAIN}"   "${REL_AG_MAIN}" "testAG.txt"        # AdGuard
          fi
          if [[ "${NEED_EXTRA}" == "1" ]]; then
            add_path "${SITE_DIR}/${OUT_UBO_EXTRA}" "${REL_UBO}"     "test_ubo_extras.txt"   # uBO
            add_path "${SITE_DIR}/${OUT_AG_EXTRA}"  "${REL_AG_EXTRA}" "test_ubo_extrasAG.txt" # AdGuard
          fi
        env:
          NEED_MAIN:  ${{ env.NEED_MAIN }}
          NEED_EXTRA: ${{ env.NEED_EXTRA }}

      - name: Snapshot updated master sources
        run: |
          set -e
          if [[ "${NEED_MAIN}" == "1" ]]; then
            cp "${SITE_DIR}/${OUT_UBO_MAIN}"   "${SITE_DIR}/${BASES_MAIN}/test-m-${{ steps.ts.outputs.epoch_min }}-${DIFF_EXPIRES_MIN}.base.txt"
          fi
          if [[ "${NEED_EXTRA}" == "1" ]]; then
            cp "${SITE_DIR}/${OUT_UBO_EXTRA}"  "${SITE_DIR}/${BASES_EXTRA}/test-extra-m-${{ steps.ts.outputs.epoch_min }}-${DIFF_EXPIRES_MIN}.base.txt"
          fi
        env:
          NEED_MAIN:  ${{ env.NEED_MAIN }}
          NEED_EXTRA: ${{ env.NEED_EXTRA }}

      - name: Regenerate patches (conditional catch-up)
        run: |
          set -euo pipefail
          NOW_EPOCH=${{ steps.ts.outputs.now_epoch }}
          RETENTION_SEC=$(( ${RETENTION_DAYS} * 24 * 3600 ))

          # Julkaisut (gh-pages)
          UBO_MAIN="${SITE_DIR}/${OUT_UBO_MAIN}"
          AG_MAIN="${SITE_DIR}/${OUT_AG_MAIN}"
          UBO_EXTRA="${SITE_DIR}/${OUT_UBO_EXTRA}"
          AG_EXTRA="${SITE_DIR}/${OUT_AG_EXTRA}"

          # SHA1 julkaisuille (uBO/AG käyttävät own-content -checksumia)
          SHA1_UBO_MAIN=$( [[ -f "${UBO_MAIN}"   ]] && sha1sum "${UBO_MAIN}"   | awk '{print $1}' || echo "" )
          SHA1_UBO_EXTRA=$( [[ -f "${UBO_EXTRA}" ]] && sha1sum "${UBO_EXTRA}"  | awk '{print $1}' || echo "" )

          # Helper: kirjoita bundle uBO-date-nimellä JA valinnaisella AdGuard-nimellä
          write_bundle_pair() {
            local base_epoch="$1" content_file="$2" ag_name="$3"
            Y=$(date -u -d "@${base_epoch}" +%Y); Mo=$(date -u -d "@${base_epoch}" +%-m)
            D=$(date -u -d "@${base_epoch}" +%-d); H=$(date -u -d "@${base_epoch}" +%H)
            Mi=$(date -u -d "@${base_epoch}" +%M); MINS=$(( 10#${H}*60 + 10#${Mi} ))
            # uBO-date
            UBO="${Y}.${Mo}.${D}.${MINS}.patch"
            cat "${content_file}" > "${SITE_DIR}/${PATCH_DIR}/${UBO}"
            # AdGuard-nimi (jos annettu)
            if [[ -n "$ag_name" ]]; then
              cat "${content_file}" > "${SITE_DIR}/${PATCH_DIR}/${ag_name}"
            fi
          }

          # === CASE 1: EXTRA muuttui (→ myös MAIN mukaan). Tee YKSI yhdistetty bundle (2 lohkoa) ja kirjoita se kolmeen tiedostoon. ===
          if [[ "${NEED_EXTRA}" == "1" ]]; then
            shopt -s nullglob
            for BF in "${SITE_DIR}/${BASES_MAIN}"/test-*-*.base.txt; do
              BN=$(basename "$BF")  # test-m-29301234-300.base.txt
              EPOCH_MIN=$(echo "$BN" | sed -n 's/^test-m-\([0-9]\+\)-[0-9]\+\.base\.txt$/\1/p') || true
              [[ -z "$EPOCH_MIN" ]] && { echo "Skip MAIN base: $BN"; continue; }

              BASE_EPOCH=$(( EPOCH_MIN * 60 ))
              AGE=$(( NOW_EPOCH - BASE_EPOCH ))

              # Retention: poista snapshot + kaikki kyseiseen baseen liittyvät patchit (uBO-date + kaksi AG-nimeä)
              if (( AGE > RETENTION_SEC )); then
                Y=$(date -u -d "@${BASE_EPOCH}" +%Y); Mo=$(date -u -d "@${BASE_EPOCH}" +%-m)
                D=$(date -u -d "@${BASE_EPOCH}" +%-d); H=$(date -u -d "@${BASE_EPOCH}" +%H)
                Mi=$(date -u -d "@${BASE_EPOCH}" +%M); MINS=$(( 10#${H}*60 + 10#${Mi} ))
                rm -f "$BF" \
                      "${SITE_DIR}/${BASES_EXTRA}/test-extra-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.base.txt" \
                      "${SITE_DIR}/${PATCH_DIR}/${Y}.${Mo}.${D}.${MINS}.patch" \
                      "${SITE_DIR}/${PATCH_DIR}/testAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch" \
                      "${SITE_DIR}/${PATCH_DIR}/test_ubo_extrasAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
                continue
              fi

              # Difffit base -> current (MAIN + EXTRA samalla base-hetkellä)
              diff -n "$BF" "${UBO_MAIN}" > raw_main.patch || true
              L_MAIN=$(wc -l < raw_main.patch | tr -d ' ')

              BF_EXTRA="${SITE_DIR}/${BASES_EXTRA}/test-extra-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.base.txt"
              if [[ -f "$BF_EXTRA" ]]; then
                diff -n "$BF_EXTRA" "${UBO_EXTRA}" > raw_extra.patch || true
              else
                : > raw_extra.patch
              fi
              L_EXTRA=$(wc -l < raw_extra.patch | tr -d ' ')

              {
                echo "diff name:test.txt checksum:${SHA1_UBO_MAIN} lines:${L_MAIN}"
                cat raw_main.patch
                echo "diff name:test_ubo_extras.txt checksum:${SHA1_UBO_EXTRA} lines:${L_EXTRA}"
                cat raw_extra.patch
              } > bundle.patch

              # Kirjoita sama bundle kolmeen nimeen:
              write_bundle_pair "$BASE_EPOCH" bundle.patch "testAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
              # Lisäksi myös EXTRA:n AG-nimelle:
              cat bundle.patch > "${SITE_DIR}/${PATCH_DIR}/test_ubo_extrasAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
            done
            shopt -u nullglob
          fi

          # === CASE 2: VAIN MAIN muuttui. Tee yhden lohkon bundle ja kirjoita uBO-date + testAG-m-... ===
          if [[ "${NEED_MAIN}" == "1" && "${NEED_EXTRA}" == "0" ]]; then
            shopt -s nullglob
            for BF in "${SITE_DIR}/${BASES_MAIN}"/test-*-*.base.txt; do
              BN=$(basename "$BF")
              EPOCH_MIN=$(echo "$BN" | sed -n 's/^test-m-\([0-9]\+\)-[0-9]\+\.base\.txt$/\1/p') || true
              [[ -z "$EPOCH_MIN" ]] && { echo "Skip MAIN base: $BN"; continue; }

              BASE_EPOCH=$(( EPOCH_MIN * 60 ))
              AGE=$(( NOW_EPOCH - BASE_EPOCH ))

              if (( AGE > RETENTION_SEC )); then
                Y=$(date -u -d "@${BASE_EPOCH}" +%Y); Mo=$(date -u -d "@${BASE_EPOCH}" +%-m)
                D=$(date -u -d "@${BASE_EPOCH}" +%-d); H=$(date -u -d "@${BASE_EPOCH}" +%H)
                Mi=$(date -u -d "@${BASE_EPOCH}" +%M); MINS=$(( 10#${H}*60 + 10#${Mi} ))
                rm -f "$BF" \
                      "${SITE_DIR}/${PATCH_DIR}/${Y}.${Mo}.${D}.${MINS}.patch" \
                      "${SITE_DIR}/${PATCH_DIR}/testAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
                continue
              fi

              diff -n "$BF" "${UBO_MAIN}" > raw_main.patch || true
              LINES=$(wc -l < raw_main.patch | tr -d ' ')
              {
                echo "diff name:test.txt checksum:${SHA1_UBO_MAIN} lines:${LINES}"
                cat raw_main.patch
              } > bundle_main.patch

              write_bundle_pair "$BASE_EPOCH" bundle_main.patch "testAG-m-${EPOCH_MIN}-${DIFF_EXPIRES_MIN}.patch"
            done
            shopt -u nullglob
          fi

          # Debug
          echo "==== SAMPLE HEADS ===="
          for f in "${UBO_MAIN}" "${AG_MAIN}" "${UBO_EXTRA}" "${AG_EXTRA}"; do
            [[ -f "$f" ]] && { echo "-- $f"; sed -n '1,20p' "$f"; }
          done
          echo "==== SAMPLE PATCH ===="
          ls -1 "${SITE_DIR}/${PATCH_DIR}"/*.patch | head -n1 | while read -r P; do
            echo "Patch: $P"; sed -n '1,10p' "$P"
          done

      - name: Commit & push gh-pages
        working-directory: ${{ env.SITE_DIR }}
        run: |
          set -e
          git config user.email "${GH_EMAIL}"
          git config user.name  "${GH_NAME}"
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "Update modified filter lists"
            git push origin HEAD:gh-pages
          else
            echo "No changes to publish."
          fi
