name: Publish test.txt with differential updates (uBO + AdGuard, catch-up)

on:
  push:
    branches: [ master ]
    paths:
      - 'test.txt'

jobs:
  publish-test:
    runs-on: ubuntu-latest

    env:
      GH_EMAIL: "actions@users.noreply.github.com"
      GH_NAME:  "github-actions[bot]"
      SITE_DIR: "site"         # gh-pages worktree
      PATCH_DIR: "patches"     # patch-kansio gh-pagesissa
      BASES_DIR: "bases/test"  # snapshotit gh-pagesissa
      DIFF_RESOLUTION: "m"     # m = minutes (nimiin)
      DIFF_EXPIRES_MIN: "300"  # 5 h minuutteina -> ...-300.patch
      LIST_FILE: "test.txt"    # käsitellään vain tämä tiedosto
      RETENTION_DAYS: "30"     # säilytä 30 päivää

    steps:
      - name: Checkout master
        uses: actions/checkout@v4
        with:
          ref: master

      - name: Prepare gh-pages worktree
        run: |
          set -e
          git fetch --depth=1 origin gh-pages:gh-pages || true
          git worktree add "${SITE_DIR}" gh-pages || git checkout gh-pages
          mkdir -p "${SITE_DIR}/${PATCH_DIR}" "${SITE_DIR}/${BASES_DIR}"

      - name: Compute timestamps (RFC 2822, Europe/Helsinki)
        id: ts
        run: |
          RFC2822=$(TZ=Europe/Helsinki date -R)
          EPOCH_MIN=$(( $(date -u +%s) / 60 ))
          NOW_EPOCH=$(date -u +%s)
          echo "rfc2822=${RFC2822}"      >> $GITHUB_OUTPUT
          echo "epoch_min=${EPOCH_MIN}"  >> $GITHUB_OUTPUT
          echo "now_epoch=${NOW_EPOCH}"  >> $GITHUB_OUTPUT

      - name: Build gh-pages version + regenerate ALL bundle patches (catch-up)
        run: |
          set -euo pipefail

          SRC="${LIST_FILE}"
          DEST="${SITE_DIR}/${LIST_FILE}"

          # edellinen julkaistu versio (jos ei ole, tyhjä tiedosto)
          if [[ -f "${DEST}" ]]; then
            cp "${DEST}" prev.txt
          else
            touch prev.txt
          fi

          # 1) Lataa master-versio ja päivitä headerit deterministisesti awkilla
          cp "${SRC}" new_raw.txt

          # Rakennetaan new.txt:
          #  - päivitettään/ lisätään ! Last modified: <RFC2822>
          #  - säilytetään kaikki rivit, mutta poistetaan mahdolliset vanhat '! Diff-Path:'-rivit
          #  - varmistetaan '! Diff-Expires: 5 hours' ja lisätään se heti '! Expires:'-rivin jälkeen (jos puuttuu)
          awk -v lm="! Last modified: ${RFC2822}" '
            BEGIN{ done_lm=0 }
            {
              if ($0 ~ /^! +Last modified:/) {
                if (!done_lm) { print lm; done_lm=1 }
                next
              }
              if ($0 ~ /^! +Diff-Path:/) { next }   # poista vanha Diff-Path
              print
            }
            END {
              if (!done_lm) print lm
            }
          ' new_raw.txt > tmp1.txt

          # Lisää/korvaa Diff-Expires (=5 hours). Jos puuttuu, lisää heti Expires-rivin perään.
          awk '
            BEGIN{ added=0 }
            {
              print $0
              if ($0 ~ /^! +Expires:/) {
                exppos=NR
              }
            }
            END {
              # tarkista oliko Diff-Expires valmiina
            }
          ' tmp1.txt > tmp1a.txt

          # Korvaa mahdollinen olemassa oleva Diff-Expires, tai lisää jos puuttuu
          if grep -qE '^! +Diff-Expires:' tmp1a.txt; then
            sed -E 's/^! +Diff-Expires:.*/! Diff-Expires: 5 hours/' tmp1a.txt > tmp2.txt
          else
            awk '
              BEGIN{ added=0 }
              {
                print
                if ($0 ~ /^! +Expires:/ && !added) {
                  print "! Diff-Expires: 5 hours"
                  added=1
                }
              }
              END {
                if (!added) print "! Diff-Expires: 5 hours"
              }
            ' tmp1a.txt > tmp2.txt
          fi

          # 1c) Laske tämän julkaisun patchin nimi ja lisää uusi Diff-Path REL + #test.txt
          PATCH_NAME="test-${DIFF_RESOLUTION}-${{ steps.ts.outputs.epoch_min }}-${DIFF_EXPIRES_MIN}.patch"
          REL_PATCH_PATH="${PATCH_DIR}/${PATCH_NAME}"

          awk -v p="! Diff-Path: " -v v="${REL_PATCH_PATH}#test.txt" '
            BEGIN{ inserted=0 }
            {
              print
              if ($0 ~ /^! +Diff-Expires:/ && !inserted) {
                print p v
                inserted=1
              }
            }
            END {
              if (!inserted) print p v
            }
          ' tmp2.txt > new.txt

          # sanity: Diff-Path on juuri luotava tiedosto + lohkonimi
          grep -qE "^! Diff-Path: ${REL_PATCH_PATH}#test.txt$" new.txt || { echo "ERROR: Diff-Path mismatch"; sed -n '1,40p' new.txt; exit 1; }

          # 2) Kirjoita uusi gh-pages versio
          cp new.txt "${DEST}"

          # 3) Tallenna snapshot nykyisestä versiosta catch-upia varten
          SNAP_BASE="${SITE_DIR}/${BASES_DIR}/test-${DIFF_RESOLUTION}-${{ steps.ts.outputs.epoch_min }}-${DIFF_EXPIRES_MIN}.base.txt"
          cp new.txt "${SNAP_BASE}"

          # 4) Regeneroi KAIKKI snapshotit -> NYKYINEN (bundle patch), ylikirjoita vastaavat patchit
          NOW_EPOCH=${{ steps.ts.outputs.now_epoch }}
          RETENTION_SEC=$(( ${RETENTION_DAYS} * 24 * 3600 ))
          SHA1_FULL=$(sha1sum new.txt | awk '{print $1}')

          shopt -s nullglob
          for BF in "${SITE_DIR}/${BASES_DIR}"/test-*-*.base.txt; do
            BN=$(basename "$BF")                  # esim. test-m-29301234-300.base.txt
            ID="${BN%.base.txt}"                  # test-m-29301234-300
            # poimi epoch_min (= toinen numero väliviivojen välissä)
            EPOCH_MIN=$(echo "$ID" | sed -n 's/^test-m-\([0-9]\+\)-[0-9]\+$/\1/p' || true)

            # jos nimi ei täsmää kaavaan, ohita
            if [[ -z "${EPOCH_MIN}" ]]; then
              echo "Skip unknown base filename: $BN"
              continue
            fi

            AGE=$(( NOW_EPOCH - EPOCH_MIN * 60 ))

            # Retention: poista liian vanhat snapshotit + patchit
            if (( AGE > RETENTION_SEC )); then
              echo "Prune >${RETENTION_DAYS}d: $BN"
              rm -f "${BF}"
              rm -f "${SITE_DIR}/${PATCH_DIR}/${ID}.patch"
              continue
            fi

            # Generoi RCS-diff (base -> new)
            diff -n "$BF" new.txt > raw.patch || true
            LINES=$(wc -l < raw.patch | tr -d ' ')

            # Kirjoita bundle: diff header + RCS-runko (ylikirjoita vanha patch samalla nimellä)
            {
              echo "diff name:test.txt checksum:${SHA1_FULL} lines:${LINES}"
              cat raw.patch
            } > "${SITE_DIR}/${PATCH_DIR}/${ID}.patch"
          done
          shopt -u nullglob

          # 5) Pieni debug-printti lokiin (helpottaa varmistusta)
          echo "==== HEAD(test.txt) ===="
          sed -n '1,20p' "${DEST}" || true
          echo "==== SAMPLE PATCH HEAD ===="
          ls -1 "${SITE_DIR}/${PATCH_DIR}"/test-*.patch | head -n1 | while read -r P; do
            echo "Patch file: ${P}"
            sed -n '1,5p' "$P"
          done
        env:
          RFC2822: ${{ steps.ts.outputs.rfc2822 }}

      - name: Commit & push gh-pages
        working-directory: ${{ env.SITE_DIR }}
        run: |
          set -e
          git config user.email "${GH_EMAIL}"
          git config user.name  "${GH_NAME}"
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "Update modified filter lists"
            git push origin HEAD:gh-pages
          else
            echo "No changes to publish."
          fi
